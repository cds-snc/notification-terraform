name: "Terragrunt plan STAGING"

env:
  ENVIRONMENT: staging
  ACCOUNT_ID: ${{ secrets.STAGING_AWS_ACCOUNT_ID }}
  AWS_REGION: ca-central-1
  OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN_STAGING }}
  TERRAFORM_VERSION: 1.11.4
  TERRAGRUNT_VERSION: 0.77.22
  WORKFLOW: true

on:
  workflow_dispatch:
  pull_request:
    paths:
      - ".env"
      - "aws/**"
      - "env/$ENVIRONMENT/**"
      - "env/terragrunt.hcl"
      - "env/*.tfvars"
      - ".github/workflows/terragrunt_plan_$ENVIRONMENT.yml"

permissions:
  id-token: write # This is required for requesting the OIDC JWT
  contents: write # This is required for actions/checkout
  pull-requests: write

jobs:
  terragrunt-run-all-plan:
    runs-on: ubuntu-latest
    outputs:
      exitcode: ${{ steps.plan.outputs.exitcode }}
    steps:
      - name: Checkout
        uses: actions/checkout@d632683dd7b4114ad314bca15554477dd762a938 # v4.2.0
      
      - uses: ./.github/actions/setup-terraform
        with:
          role_to_assume: arn:aws:iam::${{env.ACCOUNT_ID}}:role/notification-terraform-plan
          role_session_name: NotifyTerraformPlan
      
      - name: Install 1Pass CLI and Download TFVars
        run: |
          curl -o 1pass.deb https://downloads.1password.com/linux/debian/amd64/stable/1password-cli-amd64-latest.deb
          sudo dpkg -i 1pass.deb
          sudo mkdir -p aws && cd aws
          op read op://4eyyuwddp6w4vxlabrr2i2duxm/"TERRAFORM_SECRETS_${{env.ENVIRONMENT}}"/notesPlain > ${{env.ENVIRONMENT}}.tfvars
      
      - name: Terragrunt Run All Plan
        id: plan
        working-directory: env/${{env.ENVIRONMENT}}
        run: |
          set +e  # Don't exit on error so we can capture output
          
          # Run terragrunt plan on all modules except quicksight and aws-auth
          # Save binary plan files for JSON conversion
          terragrunt run-all plan \
            --terragrunt-exclude-dir quicksight \
            --terragrunt-exclude-dir aws-auth \
            --terragrunt-non-interactive \
            --terragrunt-parallelism 20 \
            -out=tfplan 2>&1 | tee plan_output.txt
          
          PLAN_EXIT_CODE=${PIPESTATUS[0]}
          
          # Debug: Check if text output file exists and show size
          if [ -f "plan_output.txt" ]; then
            echo "Plan text output file size: $(wc -c < plan_output.txt) bytes"
            echo "Plan text output file lines: $(wc -l < plan_output.txt) lines"
          fi
          
          # Set exit code as output for the comment step
          echo "exitcode=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
          
          exit $PLAN_EXIT_CODE
          
      - name: Generate JSON Plan Files
        id: json-plans
        working-directory: env/${{env.ENVIRONMENT}}
        run: |
          echo "Generating JSON plan outputs..."
          
          # Find all tfplan files and convert them to JSON
          find . -name "tfplan" -type f | while read -r plan_file; do
            module_dir=$(dirname "$plan_file")
            module_name=$(basename "$module_dir")
            
            echo "Processing module: $module_name in $module_dir"
            
            cd "$module_dir"
            if terragrunt show -json tfplan > "${module_name}_plan.json" 2>/dev/null; then
              echo "‚úì Generated JSON for module: $module_name"
              # Check if the plan has changes
              if [ -s "${module_name}_plan.json" ]; then
                echo "  JSON file size: $(wc -c < "${module_name}_plan.json") bytes"
              fi
            else
              echo "‚úó Failed to generate JSON for module: $module_name"
            fi
            cd - > /dev/null
          done
          
          # Create a list of all JSON files for the comment step
          find . -name "*_plan.json" -type f > json_plans_list.txt
          echo "Found $(wc -l < json_plans_list.txt) JSON plan files:"
          cat json_plans_list.txt

      - name: Upload plan outputs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: plan-output-staging
          path: |
            env/${{ env.ENVIRONMENT }}/plan_output.txt
            env/${{ env.ENVIRONMENT }}/**/*_plan.json
            env/${{ env.ENVIRONMENT }}/json_plans_list.txt
          retention-days: 1

  comment-pr:
    needs: terragrunt-run-all-plan
    if: always() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Download plan outputs
        uses: actions/download-artifact@v4
        with:
          name: plan-output-staging
          path: ./plan-outputs

      - name: Create PR comments from JSON plans
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Read the exit code from the plan step
            const exitCode = '${{ needs.terragrunt-run-all-plan.outputs.exitcode }}';
            
            // Function to analyze a JSON plan and extract changes
            function analyzePlan(jsonPlan) {
              try {
                const plan = JSON.parse(jsonPlan);
                
                console.log('=== JSON Plan Analysis Debug ===');
                console.log('Plan keys:', Object.keys(plan));
                console.log('Has resource_changes:', !!plan.resource_changes);
                
                if (plan.resource_changes) {
                  console.log('Resource changes count:', plan.resource_changes.length);
                  console.log('First few resource changes:', JSON.stringify(plan.resource_changes.slice(0, 3), null, 2));
                }
                
                if (!plan.resource_changes || plan.resource_changes.length === 0) {
                  console.log('No resource_changes found in plan');
                  return { hasChanges: false, summary: 'No resource changes found in plan.' };
                }
                
                const changes = {
                  create: [],
                  update: [],
                  delete: [],
                  replace: []
                };
                
                let totalChanges = 0;
                
                plan.resource_changes.forEach((change, index) => {
                  console.log(`Processing resource change ${index}:`, {
                    type: change.type,
                    name: change.name,
                    actions: change.change?.actions
                  });
                  
                  const resourceName = `${change.type}.${change.name}`;
                  
                  if (change.change && change.change.actions) {
                    const actions = change.change.actions;
                    
                    if (actions.includes('create')) {
                      changes.create.push(resourceName);
                      totalChanges++;
                    } else if (actions.includes('delete') && actions.includes('create')) {
                      changes.replace.push(resourceName);
                      totalChanges++;
                    } else if (actions.includes('update')) {
                      changes.update.push(resourceName);
                      totalChanges++;
                    } else if (actions.includes('delete')) {
                      changes.delete.push(resourceName);
                      totalChanges++;
                    }
                  } else {
                    console.log(`Resource change ${index} has no change.actions:`, JSON.stringify(change, null, 2));
                  }
                });
                
                console.log('Total changes detected:', totalChanges);
                console.log('Changes breakdown:', changes);
                
                if (totalChanges === 0) {
                  return { hasChanges: false, summary: 'No actionable changes detected.' };
                }
                
                // Build summary
                let summary = `**Plan Summary:** ${totalChanges} change(s)\n\n`;
                
                if (changes.create.length > 0) {
                  summary += `**${changes.create.length} to create:**\n`;
                  changes.create.forEach(resource => {
                    summary += `- üü¢ ${resource}\n`;
                  });
                  summary += '\n';
                }
                
                if (changes.update.length > 0) {
                  summary += `**${changes.update.length} to update:**\n`;
                  changes.update.forEach(resource => {
                    summary += `- üü° ${resource}\n`;
                  });
                  summary += '\n';
                }
                
                if (changes.replace.length > 0) {
                  summary += `**${changes.replace.length} to replace:**\n`;
                  changes.replace.forEach(resource => {
                    summary += `- üîÑ ${resource}\n`;
                  });
                  summary += '\n';
                }
                
                if (changes.delete.length > 0) {
                  summary += `**${changes.delete.length} to delete:**\n`;
                  changes.delete.forEach(resource => {
                    summary += `- üî¥ ${resource}\n`;
                  });
                  summary += '\n';
                }
                
                return { hasChanges: true, summary, changes };
                
              } catch (error) {
                console.error('Error parsing JSON plan:', error);
                console.error('JSON content preview:', jsonPlan.substring(0, 500));
                return { hasChanges: false, summary: `Error parsing plan: ${error.message}` };
              }
            }
            
            // Create summary comment first
            const summaryOutput = `#### üèóÔ∏è Terragrunt Plan Summary for staging
            
            *Plan exit code: ${exitCode}*
            *Action: \`${{ github.event_name }}\`*
            
            üìã Individual module plans are posted as separate comments below.`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summaryOutput
            });
            
            // Read the list of JSON plan files
            const jsonPlansListPath = './plan-outputs/json_plans_list.txt';
            
            if (!fs.existsSync(jsonPlansListPath)) {
              console.log('No JSON plans list found');
              return;
            }
            
            const jsonPlanFiles = fs.readFileSync(jsonPlansListPath, 'utf8')
              .split('\n')
              .filter(line => line.trim().length > 0)
              .map(line => line.trim());
            
            console.log(`Found ${jsonPlanFiles.length} JSON plan files`);
            
            let commentsCreated = 0;
            let modulesWithChanges = 0;
            
            // Debug: Create a comment with the first JSON file for inspection
            if (jsonPlanFiles.length > 0) {
              const firstJsonFile = `./plan-outputs/${jsonPlanFiles[0]}`;
              if (fs.existsSync(firstJsonFile)) {
                const firstJsonContent = fs.readFileSync(firstJsonFile, 'utf8');
                const debugComment = `#### üîç Debug: Sample JSON Plan Structure\n\n**File:** \`${jsonPlanFiles[0]}\`\n**Size:** ${firstJsonContent.length} characters\n\n**JSON Preview:**\n\`\`\`json\n${firstJsonContent.substring(0, 2000)}\n\`\`\`\n\n**Keys available:** ${Object.keys(JSON.parse(firstJsonContent)).join(', ')}`;
                
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: debugComment
                });
              }
            }
            
            // Process each JSON plan file
            for (const relativePath of jsonPlanFiles) {
              const fullPath = `./plan-outputs/${relativePath}`;
              
              console.log(`Checking file: ${fullPath}`);
              console.log(`File exists: ${fs.existsSync(fullPath)}`);
              
              if (fs.existsSync(fullPath)) {
                const moduleMatch = path.basename(relativePath).match(/(.+)_plan\.json$/);
                if (!moduleMatch) {
                  console.log(`Skipping file - doesn't match pattern: ${relativePath}`);
                  continue;
                }
                
                const moduleName = moduleMatch[1];
                console.log(`Processing module: ${moduleName} from file: ${relativePath}`);
                
                try {
                  const jsonContent = fs.readFileSync(fullPath, 'utf8');
                  console.log(`JSON content length: ${jsonContent.length} characters`);
                  console.log(`JSON content preview: ${jsonContent.substring(0, 200)}...`);
                  
                  const analysis = analyzePlan(jsonContent);
                  console.log(`Analysis result for ${moduleName}:`, analysis);
                  
                  if (analysis.hasChanges) {
                    modulesWithChanges++;
                    
                    const moduleComment = `#### üì¶ Module: \`${moduleName}\`\n\n${analysis.summary}\n\n*<details><summary>View JSON Plan</summary>*\n\n\`\`\`json\n${JSON.stringify(JSON.parse(jsonContent), null, 2).substring(0, 10000)}\n\`\`\`\n\n*</details>*`;
                    
                    await github.rest.issues.createComment({
                      issue_number: context.issue.number,
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      body: moduleComment
                    });
                    
                    commentsCreated++;
                    console.log(`‚úì Created comment for module: ${moduleName}`);
                  } else {
                    console.log(`‚úó Skipping module ${moduleName} - no changes detected: ${analysis.summary}`);
                  }
                } catch (error) {
                  console.error(`Error processing module ${moduleName}:`, error);
                }
              } else {
                console.log(`File not found: ${fullPath}`);
              }
            }
            
            console.log(`Created ${commentsCreated} module comments for ${modulesWithChanges} modules with changes`);

