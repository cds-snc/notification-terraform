name: "Terragrunt plan STAGING"

env:
  ENVIRONMENT: staging
  ACCOUNT_ID: ${{ secrets.STAGING_AWS_ACCOUNT_ID }}
  AWS_REGION: ca-central-1
  OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN_STAGING }}
  TERRAFORM_VERSION: 1.11.4
  TERRAGRUNT_VERSION: 0.77.22
  WORKFLOW: true

on:
  workflow_dispatch:
  pull_request:
    paths:
      - ".env"
      - "aws/**"
      - "env/$ENVIRONMENT/**"
      - "env/terragrunt.hcl"
      - "env/*.tfvars"
      - ".github/workflows/terragrunt_plan_$ENVIRONMENT.yml"

permissions:
  id-token: write # This is required for requesting the OIDC JWT
  contents: write # This is required for actions/checkout
  pull-requests: write

jobs:
  terragrunt-run-all-plan:
    runs-on: ubuntu-latest
    outputs:
      exitcode: ${{ steps.plan.outputs.exitcode }}
    steps:
      - name: Checkout
        uses: actions/checkout@d632683dd7b4114ad314bca15554477dd762a938 # v4.2.0
      
      - uses: ./.github/actions/setup-terraform
        with:
          role_to_assume: arn:aws:iam::${{env.ACCOUNT_ID}}:role/notification-terraform-plan
          role_session_name: NotifyTerraformPlan
      
      - name: Install 1Pass CLI and Download TFVars
        run: |
          curl -o 1pass.deb https://downloads.1password.com/linux/debian/amd64/stable/1password-cli-amd64-latest.deb
          sudo dpkg -i 1pass.deb
          sudo mkdir -p aws && cd aws
          op read op://4eyyuwddp6w4vxlabrr2i2duxm/"TERRAFORM_SECRETS_${{env.ENVIRONMENT}}"/notesPlain > ${{env.ENVIRONMENT}}.tfvars
      
      - name: Terragrunt Run All Plan
        id: plan
        working-directory: env/${{env.ENVIRONMENT}}
        run: |
          set +e  # Don't exit on error so we can capture output
          
          # Run terragrunt plan on all modules except quicksight and aws-auth
          terragrunt run-all plan \
            --terragrunt-exclude-dir quicksight \
            --terragrunt-exclude-dir aws-auth \
            --terragrunt-non-interactive \
            --terragrunt-parallelism 20 2>&1 | tee plan_output.txt
          
          PLAN_EXIT_CODE=${PIPESTATUS[0]}
          
          # Debug: Check if file exists and show size
          echo "Plan output file size: $(wc -c < plan_output.txt) bytes"
          echo "Plan output file lines: $(wc -l < plan_output.txt) lines"
          
          # Set exit code as output for the comment step
          echo "exitcode=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
          
          exit $PLAN_EXIT_CODE
          
      - name: Upload plan output
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: plan-output
          path: env/${{env.ENVIRONMENT}}/plan_output.txt
          retention-days: 1

  comment-pr:
    needs: terragrunt-run-all-plan
    if: always() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Download plan output
        uses: actions/download-artifact@v4
        with:
          name: plan-output
          path: ./
          
      - name: Parse and Comment Plan Results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read the plan output from artifact
            let planOutput = '';
            let exitCode = '${{ needs.terragrunt-run-all-plan.outputs.exitcode }}';
            
            try {
              planOutput = fs.readFileSync('plan_output.txt', 'utf8');
              console.log(`Read plan output: ${planOutput.length} characters`);
            } catch (error) {
              console.log('Could not read plan output file:', error.message);
              planOutput = 'Error: Could not read plan output';
            }
            
            // Create summary comment first
            const summaryOutput = `#### üèóÔ∏è Terragrunt Plan Summary for ${{env.ENVIRONMENT}}
            
            *Plan exit code: ${exitCode}*
            *Action: \`${{ github.event_name }}\`*
            *Total output size: ${planOutput.length} characters*
            
            üìã Individual module plans are posted as separate comments below.`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summaryOutput
            });
            
            // Debug: Show first 1000 characters to understand the format
            console.log('First 1000 characters of output:');
            console.log(planOutput.substring(0, 1000));
            
            // More flexible parsing - look for various terragrunt patterns
            const lines = planOutput.split('\n');
            const modules = new Map();
            let currentModule = '';
            let currentModuleOutput = [];
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Look for terragrunt module indicators
              let moduleMatch = null;
              
              // Pattern 1: "=> Executing terraform plan in /path/to/env/staging/module"
              if (line.includes('Executing') && line.includes('env/staging/')) {
                moduleMatch = line.match(/env\/staging\/([^\/\s]+)/);
              }
              // Pattern 2: "=> Running terraform plan in /path/to/env/staging/module"
              else if (line.includes('Running') && line.includes('env/staging/')) {
                moduleMatch = line.match(/env\/staging\/([^\/\s]+)/);
              }
              // Pattern 3: Just the module path in working directory context
              else if (line.includes('env/staging/') && (line.includes('terraform') || line.includes('plan'))) {
                moduleMatch = line.match(/env\/staging\/([^\/\s]+)/);
              }
              // Pattern 4: Directory path pattern
              else if (line.match(/^.*env\/staging\/([^\/\s]+).*$/)) {
                moduleMatch = line.match(/env\/staging\/([^\/\s]+)/);
              }
              
              if (moduleMatch) {
                // Save previous module if exists
                if (currentModule && currentModuleOutput.length > 0) {
                  modules.set(currentModule, currentModuleOutput.join('\n'));
                }
                
                currentModule = moduleMatch[1];
                currentModuleOutput = [line];
                console.log(`Found module: ${currentModule}`);
              } else if (currentModule) {
                currentModuleOutput.push(line);
              }
            }
            
            // Save the last module
            if (currentModule && currentModuleOutput.length > 0) {
              modules.set(currentModule, currentModuleOutput.join('\n'));
            }
            
            console.log(`Found ${modules.size} modules: ${Array.from(modules.keys()).join(', ')}`);
            
            // If no modules found with pattern matching, try splitting by chunks
            if (modules.size === 0) {
              console.log('No modules found with pattern matching, trying chunk approach...');
              
              // Split by empty lines and look for chunks with env/staging
              const chunks = planOutput.split(/\n\s*\n/);
              let chunkIndex = 0;
              
              for (const chunk of chunks) {
                if (chunk.includes('env/staging/')) {
                  const moduleMatch = chunk.match(/env\/staging\/([^\/\s]+)/);
                  if (moduleMatch) {
                    const moduleName = moduleMatch[1];
                    modules.set(`${moduleName}-${chunkIndex}`, chunk);
                    console.log(`Found chunk module: ${moduleName}-${chunkIndex}`);
                  }
                }
                chunkIndex++;
              }
            }
            
            // Post module comments
            let moduleCount = 0;
            const maxCommentSize = 60000;
            
            for (const [moduleName, output] of modules) {
              let moduleOutput = output;
              if (moduleOutput.length > maxCommentSize) {
                moduleOutput = moduleOutput.substring(0, maxCommentSize - 500) + '\n\n... (output truncated due to size)';
              }
              
              const moduleComment = `#### üì¶ Module: \`${moduleName}\`
              
              \`\`\`
              ${moduleOutput.trim()}
              \`\`\``;
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: moduleComment
              });
              
              moduleCount++;
              await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            console.log(`Created ${moduleCount} module comments`);